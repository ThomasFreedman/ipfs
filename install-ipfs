#!/bin/bash

# This script will install IPFS software and establish initial settings.
# This must be executed with root privileges or with sudo.
#
# Options:

usage() {
  echo "None of the following options are required (default values will be used):"
  echo "-a == autostart method, 0 or 1. 0 == systemd (default), 1 == cron @reboot"
  echo "-d == distribution upgrade, 0 or 1. Standard update/upgrade only (default) "
  echo "-g == go version. Default is NoGo. Use 1.10.1 if -g and no option value provided"
  echo "-m == max storage space. Default is 75% of disk. Option value integer in gigabytes"
  echo "-n == install from siderus apt repo. Default, not Go. Invalid if -g is specified"
  echo "-s == Single step / debug. Default is no waiting, non single step / debug mode"
  echo "-h == print this usage info and exit. Also for --help"
}

if [[ $(id -u) -ne 0 ]] ; then echo "Please run as root, or prefix with 'sudo'" ; exit 1 ; fi

# Calculate disk space available for IPFS
FREE=`df --output=avail -B 1 / | tail -n 1` # Free space in bytes on root partition
MAX=`expr $FREE / 1320000000`      # Approximately 75% of free space (in GB)
printf -v STORAGE_MAX %dG $MAX     # The default StorageMax parameter value

AUTO=0                             # Default autostart method 0 == systemd, 1 == cron @reboot
WAIT=0                             # Default value for single step / debug mode (no wait)
DISTUP=0                           # Default value for dist-upgrade (don't do it!)
GOVER=NoGo                         # Default Go language version (Don't use go version)
CONFIG=/home/ipfs/.ipfs/config     # IPFS configuration file

# Determine OpSys (Raspbian or Debian)
OS=`lsb_release -is`
if [[ $OS != "Raspbian" && $OS != "Debian" ]]; then
   echo "$OS Linux detected! This script is for Raspbian or Debian only for now."
   exit 1
fi
if [ $OS == "Raspbian" ]; then
  ARCH=armv6l;
else
  ARCH=amd64;                      # No support for 32 bit systems; should we?
fi

# Make sure we have enhanced getopt -- probably not required for most Linux distros
getopt --test
if [ $? -ne 4 ] then echo "Ouch! getopt not avialable on this system - Bye!"; exit 1; fi

# Read command line options
OPTS=`getopt -o a::dg::m:nsh --long help -name "$0" -- "$@"`
eval set -- "$OPTS"

# extract options and their arguments and set appropriate variables.
while true ; do
    case "$1" in
        -a)
            if [ "$2" != "" ]; then
              AUTO=$2;
              echo "Will use golang version $GOVER"
              shift;
            else
            SYSD=0
            shift
            ;;
        -d)
            DISTUP=1
            shift
            ;;
        -g)
            if [ "$2" != "" ]; then
              GOVER=$2;
              echo "Will use golang version $GOVER"
              shift;
            else
              GOVER=1.10.1
            fi
            shift
            ;;
        -m)
            if [ "$2" != "" ]; then
              if ! [ -z "${2//[0-9]}" ]; then          # Positive number?
                echo "-m requires a positive integer"
                exit 1
              fi
              STORAGE_MAX=$2;
              shift;
            fi
            shift
            ;;
        -n)
            if [ $GOVER ]; then
              echo "Cannot use both -g and -n options!"
              exit 1
            fi
            shift
            break
            ;;
        -h|--help)
            usage()
            exit 0
        *)
            echo "No such option: $1" >&2
            exit 1
            ;;
    esac
done


if [ ! -f ready4ipfs ]; then
  if [ ! ping -q -w 1 -c 1 storage.googleapis.com > /dev/null ]; then
    if [$OS == "Raspbian" ]; then
      # Make sure the system is configured for network access
      echo ""
      echo "The system must be configured, at least to setup networking."
      echo "REBOOT if raspi-config asks, then run this again when rebooted."
      echo "You can just exit raspi-config the second time, don't reboot."
      read -n 1 -p "Press any key to launch the raspi-config utility..." key
      raspi-config
    else
      echo ""
      echo "It doesn't appear the system is online. Make sure networking"
      echo "is operational, then try again. Bye for now!"
      exit -1
    fi
  fi
  echo "Updating the OS (Operating System)..."
  apt-get -y update
  apt-get -y upgrade
  touch ready4ipfs
  if [ $DISTUP == 1 ]; then
    echo ""
    echo "Performing a distribution upgrade, which may bump OS / kernel version..."
    apt-get -y dist-upgrade
    echo ""
    echo "Need to reboot. Afterwards, rerun this script to finish IPFS installation."
    read -n 1 -p "Press ^C to abort, or any other key to reboot..." key
    reboot
  fi
fi

if [ ! -d /home/ipfs ]; then
  echo "Preparing the ipfs user account..."
  if [ ! -d /home/ipfs ]; then useradd -m -s /bin/bash ipfs; fi
  if [ ! -d /home/ipfs/.ipfs ]; then mkdir /home/ipfs/.ipfs; fi
  if [ $GOVER != "NoGo" ]; then
    mkdir /home/ipfs/go
    chown -R ipfs.ipfs /home/ipfs
    echo "source /usr/local/bin/goInit" >> /home/ipfs/.profile  # Sets PATH and GOPATH
  fi
  echo ""
  if [ $WAIT == 1 ]; then read -n 1 -p "Press ^C to exit, any other key to proceed..." key; fi
fi

if [ "$GOVER" == "NoGo" ]; then
  if [ ! -e /etc/apt/sources.list.d/siderus.list ]; then
    echo "Installing credentials for siderus software repository..."
    apt install -y apt-transport-https curl
    curl https://get.siderus.io/key.public.asc | apt-key add -
    echo "deb https://get.siderus.io/ apt/" | tee -a /etc/apt/sources.list.d/siderus.list
    apt update
  fi
else
  if [ ! -e /usr/local/bin/go$GOVER.linux-$ARCH.tar.gz ]; then
    pushd /usr/local/bin
    echo "Installing binary golang version $GOVER from googleapis. Please be patient..."
    wget https://storage.googleapis.com/golang/go$GOVER.linux-$ARCH.tar.gz
    tar -C /usr/local -xzf go$GOVER.linux-$ARCH.tar.gz
    echo 'export GOPATH=/home/$USER/go' >> /usr/local/bin/goInit
    echo 'export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin' > /usr/local/bin/goInit

    echo "export GOPATH=/root/go" >> /root/.profile
    echo "export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin" >> /root/.profile
    popd
    mkdir /root/go
    source /root/.profile
    go version
  else
    echo "No such golang: https://storage.googleapis.com/golang/go$GOVER.linux-$ARCH.tar.gz"
    exit -1
  fi
fi
echo ""
if [ $WAIT == 1 ]; then read -n 1 -p "Press ^C to exit, any other key to proceed..." key; fi

echo "Installing IPFS and supporting packages. Please be patient..."
apt-get -y install tmux ufw
if [ $GOVER == "NoGo" ]; then
  apt-get -y install ipfs
else
  runuser -l ipfs -c 'go get -u github.com/ipfs/ipfs-update'
  runuser -l ipfs -c 'ipfs-update install latest'
fi
runuser -l ipfs -c 'ipfs init > ~/.ipfs/init.log 2>&1'   # Initialize IPFS and log output
apt -y autoremove
echo ""
if [ $WAIT == 1 ]; then read -n 1 -p "Press ^C to exit, any other key to proceed..." key; fi

echo "Opening required firewall ports..."
ufw allow 4001/tcp
ufw allow 22/tcp
echo ""
if [ $WAIT == 1 ]; then read -n 1 -p "Press ^C to exit, any other key to proceed..." key; fi

echo "Setting maximum IPFS storage to $STORAGE_MAX in config file..."
sed -i "s/^\s*\"StorageMax.*$/    ~StorageMax~: ~$STORAGE_MAX~,/g" $CONFIG
sed -i "s/~/\"/g" $CONFIG
echo ""
if [ $WAIT == 1 ]; then read -n 1 -p "Press ^C to exit, any other key to proceed..." key; fi

if [ $AUTO == 0 ]; then  # For some unknown reason this doesn't always work on debian minimal server
  echo "Creating SystemD unit to start IPFS on reboot..."
  (
  cat <<SYSD_UNIT
[Unit]
Description=IPFS daemon
After=network.target
[Service]
User=ipfs
LimitNOFILE=65536
Environment="IPFS_FD_MAX=4096"
Environment="IPFS_PATH=/home/ipfs/.ipfs"
ExecStart=/home/ipfs/go/bin/ipfs daemon --enable-namesys-pubsub
Restart=on-failure
[Install]
WantedBy=multi-user.target
SYSD_UNIT
) > /etc/systemd/system/ipfs.service

  systemctl enable ipfs
  systemctl start ipfs

else # Use this alternate way to start service on system start
  echo "#!/bin/bash" > /home/ipfs/autostart.bash
  echo ". /usr/local/bin/goInit" >> /home/ipfs/autostart.bash
  echo "export LimitNOFILE=65536" >> /home/ipfs/autostart.bash   # Might not work as env
  echo "export IPFS_FD_MAX=4096" >> /home/ipfs/autostart.bash
  echo "export IPFS_PATH=/home/ipfs/.ipfs" >> /home/ipfs/autostart.bash
  echo "/home/ipfs/go/bin/ipfs daemon --enable-namesys-pubsub" >> /home/ipfs/autostart.bash
  echo "@reboot ipfs /bin/bash /home/ipfs/autostart.bash" > /etc/cron.d/autoStart
  chmod 755 /etc/cron.d/autoStart
fi

cat /home/ipfs/.ipfs/init.log
echo ""
echo "IPFS is now installed on this system."
